# 13.2. 트랜잭션 격리
## 13.2.1. 커밋된 격리 수준 읽기
## 13.2.2. 반복 가능한 읽기 격리 수준
## 13.2.3. 직렬화 가능 격리 수준

SQL 표준은 4가지 수준의 트랜잭션 격리를 정의합니다. 가장 엄격한 것은 직렬화 가능으로, 표준에서는 직렬화 가능 트랜잭션 집합을 동시에 실행하면 순서대로 한 번에 하나씩 실행하는 것과 동일한 효과가 보장된다는 단락에 정의되어 있습니다. 나머지 세 가지 수준은 각 수준에서 발생하지 않아야 하는 동시 트랜잭션 간의 상호 작용으로 인해 발생하는 현상으로 정의됩니다. 표준은 직렬화 가능의 정의로 인해 이러한 현상 중 어느 것도 해당 수준에서 불가능하다고 지적합니다. (트랜잭션의 효과가 한 번에 하나씩 실행되는 것과 일치해야 한다면 상호작용으로 인한 현상을 어떻게 볼 수 있을까요?)

다양한 수준에서 금지되는 현상은 다음과 같습니다:

구분|설명
-|-
dirty read(더티 읽기)|트랜잭션이 동시에 커밋되지 않은 트랜잭션에 의해 쓰여진 데이터를 읽습니다.
nonrepeatable read(반복 불가능 읽기)|트랜잭션이 이전에 읽었던 데이터를 다시 읽다가 다른 트랜잭션(최초 읽기 이후 커밋된 트랜잭션)에 의해 데이터가 수정된 것을 발견하는 경우입니다.
phantom read(팬텀 읽기)|트랜잭션이 검색 조건을 만족하는 행 집합을 반환하는 쿼리를 다시 실행하고 최근에 커밋된 다른 트랜잭션으로 인해 조건을 만족하는 행 집합이 변경된 것을 발견합니다.
serialization anomaly(직렬화 이상)|트랜잭션 그룹을 성공적으로 커밋한 결과가 해당 트랜잭션을 한 번에 하나씩 실행하는 모든 가능한 순서와 일치하지 않는 경우입니다.

SQL 표준 및 PostgreSQL로 구현된 트랜잭션 격리 수준은 표 13.1에 설명되어 있습니다.

표 13.1. 트랜잭션 격리 수준

격리 수준|Dirty Read|Nonrepeatable Read|Phantom Read|Serialization Anomaly
-|-|-|-|-
읽기 커밋되지 않음|허용되지만 PG에는 없음|가능|가능|가능
커밋된 읽기|불가능|가능|가능|가능|가능|가능
반복 가능 읽기|불가능|불가능|허용되지만 PG에는 없음|가능
직렬화 가능|불가능|불가능|불가능|불가능

PostgreSQL에서는 네 가지 표준 트랜잭션 격리 수준 중 하나를 요청할 수 있지만, 내부적으로는 세 가지 격리 수준만 구현됩니다. 즉, PostgreSQL의 읽기 커밋되지 않은 모드는 읽기 커밋된 모드처럼 동작합니다. 이는 표준 격리 수준을 PostgreSQL의 다중 버전 동시성 제어 아키텍처에 매핑할 수 있는 유일한 합리적인 방법이기 때문입니다.

이 표는 또한 PostgreSQL의 반복 읽기 구현이 팬텀 읽기를 허용하지 않는다는 것을 보여줍니다. 이는 SQL 표준에서 특정 격리 수준에서 발생해서는 안 되는 예외를 지정하기 때문에 허용되며, 더 높은 수준의 보장이 허용됩니다. 사용 가능한 격리 수준의 동작은 다음 하위 섹션에 자세히 설명되어 있습니다.

트랜잭션의 트랜잭션 격리 수준을 설정하려면 [SET TRANSACTION]() 명령을 사용합니다.

### 중요
일부 PostgreSQL 데이터 유형 및 함수에는 트랜잭션 동작에 관한 특별한 규칙이 있습니다. 특히 시퀀스(따라서 직렬을 사용하여 선언된 열의 카운터)에 대한 변경 사항은 다른 모든 트랜잭션에 즉시 표시되며, 변경을 수행한 트랜잭션이 중단되는 경우 롤백되지 않습니다. [섹션 9.17]() 및 [섹션 8.1.4]()를 참조하십시오.

### 13.2.1. 커밋된 격리 수준 읽기
읽기 커밋은 PostgreSQL의 기본 격리 수준입니다. 트랜잭션이 이 격리 수준을 사용하는 경우 SELECT 쿼리(FOR UPDATE/SHARE 절이 없는)는 쿼리 시작 전에 커밋된 데이터만 보고, 커밋되지 않은 데이터나 동시 트랜잭션에 의해 쿼리 실행 중에 커밋된 변경 사항은 보지 못합니다. 사실상 SELECT 쿼리는 쿼리 실행이 시작되는 시점의 데이터베이스 스냅샷을 보게 됩니다. 그러나 SELECT는 아직 커밋되지 않았더라도 자체 트랜잭션 내에서 실행된 이전 업데이트의 효과를 볼 수 있습니다. 또한 첫 번째 SELECT가 시작된 후 두 번째 SELECT가 시작되기 전에 다른 트랜잭션이 변경 내용을 커밋하는 경우, 두 개의 연속된 SELECT 명령은 단일 트랜잭션 내에 있더라도 서로 다른 데이터를 볼 수 있다는 점에 유의하세요.

UPDATE, DELETE, SELECT FOR UPDATE 및 SELECT FOR SHARE 명령은 대상 행을 검색하는 측면에서 SELECT와 동일하게 동작하며, 명령 시작 시점에 커밋된 대상 행만 찾습니다. 그러나 이러한 대상 행을 찾을 때 이미 다른 동시 트랜잭션에 의해 업데이트(또는 삭제 또는 잠김)되었을 수 있습니다. 이 경우 업데이트자가 될 트랜잭션은 첫 번째 업데이트 트랜잭션이 커밋되거나 롤백될 때까지 기다립니다(아직 진행 중인 경우). 첫 번째 업데이트자가 롤백하면 그 효과는 무효화되고 두 번째 업데이트자는 원래 발견된 행을 계속 업데이트할 수 있습니다. 첫 번째 업데이터가 커밋하면 두 번째 업데이터는 첫 번째 업데이터가 행을 삭제한 경우 해당 행을 무시하고, 그렇지 않으면 업데이트된 행 버전에 작업을 적용하려고 시도합니다. 명령의 검색 조건(WHERE 절)을 다시 평가하여 행의 업데이트된 버전이 여전히 검색 조건과 일치하는지 확인합니다. 일치하는 경우 두 번째 업데이터는 업데이트된 버전의 행을 사용하여 작업을 진행합니다. 업데이트에 대한 선택 및 공유에 대한 선택의 경우, 이는 잠긴 행의 업데이트된 버전이 클라이언트에 반환된다는 것을 의미합니다.

ON CONFLICT DO UPDATE 절이 있는 INSERT도 비슷하게 작동합니다. 읽기 커밋 모드에서는 삽입을 위해 제안된 각 행이 삽입되거나 업데이트됩니다. 관련 없는 오류가 없는 한 이 두 가지 결과 중 하나가 보장됩니다. 충돌이 다른 트랜잭션에서 발생하여 INSERT에 아직 효과가 표시되지 않는 경우, 해당 행의 버전이 일반적으로 명령에 표시되지 않더라도 UPDATE 절이 해당 행에 영향을 미칩니다.

ON CONFLICT DO NOTHING 절이 있는 INSERT는 INSERT 스냅샷에 효과가 표시되지 않는 다른 트랜잭션의 결과로 인해 한 행에 대해 삽입이 진행되지 않을 수 있습니다. 다시 말하지만, 이는 읽기 커밋 모드에서만 발생합니다.

MERGE를 사용하면 INSERT, UPDATE, DELETE 하위 명령의 다양한 조합을 지정할 수 있습니다. INSERT 및 UPDATE 하위 명령이 모두 포함된 MERGE 명령은 ON CONFLICT DO UPDATE 절이 있는 INSERT와 비슷해 보이지만 INSERT 또는 UPDATE가 수행된다는 것을 보장하지는 않습니다. MERGE가 UPDATE 또는 DELETE를 시도하고 행이 동시에 업데이트되지만 현재 대상 및 현재 소스 튜플에 대해 조인 조건이 여전히 통과하는 경우 MERGE는 UPDATE 또는 DELETE 명령과 동일하게 작동하며 업데이트된 버전의 행에 대해 작업을 수행합니다. 그러나 MERGE는 여러 작업을 지정할 수 있고 조건부로 지정할 수 있으므로 원래 일치했던 작업이 작업 목록의 나중에 나타나더라도 각 작업의 조건은 첫 번째 작업부터 시작하여 업데이트된 버전의 행에서 다시 평가됩니다. 반면에 행이 동시에 업데이트되거나 삭제되어 조인 조건이 실패하는 경우 MERGE는 조건의 NOT MATCHED 작업을 다음에 평가하고 성공한 첫 번째 작업을 실행합니다. MERGE가 INSERT를 시도할 때 고유 인덱스가 존재하고 중복 행이 동시에 삽입되는 경우 고유성 위반 오류가 발생하며, MERGE는 MATCHED 조건의 평가를 다시 시작하여 이러한 오류를 피하려고 시도하지 않습니다.

위의 규칙으로 인해 업데이트 명령이 일관되지 않은 스냅샷을 볼 수 있습니다. 즉, 업데이트하려는 동일한 행에 대한 동시 업데이트 명령의 효과는 볼 수 있지만 데이터베이스의 다른 행에 대한 해당 명령의 효과는 볼 수 없습니다. 이 동작으로 인해 읽기 커밋 모드는 복잡한 검색 조건이 포함된 명령에는 적합하지 않지만, 간단한 경우에는 적합합니다. 예를 들어 다음과 같은 트랜잭션으로 은행 잔액을 업데이트하는 경우를 생각해 보십시오:
